<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="reset.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-F3w7mX95PdgyTmZZMECAngseQB83DfGTowi0iMjiWaeVhAn4FJkqJByhZMI3AhiU" crossorigin="anonymous">
    <link href="styles.css" rel="stylesheet">

    <title>Technical Documentation Page</title>
</head>

<body>
    <div class="container__sidebar">
        <nav id="navbar">
            <header id="navbar__title" class="text-center">
                Functions <br> in JavaScript
            </header>
            <a href="#Functions" class="nav-link p-3 text-light">Functions</a>
            <a href="#Function_declaration" class="nav-link p-3 text-light">Function declaration</a>
            <a href="#Local_variables" class="nav-link p-3 text-light">Local variables</a>
            <a href="#Outer_variables" class="nav-link p-3 text-light">Outer variables</a>
            <a href="#Parameters" class="nav-link p-3 text-light">Parameters</a>
            <a href="#Default_values" class="nav-link p-3 text-light">Default values</a>
            <a href="#Returning_a_value" class="nav-link p-3 text-light">Returning a value</a>
            <a href="#Naming_a_function" class="nav-link p-3 text-light">Naming a function</a>
            <a href="#Functions_==_Comments" class="nav-link p-3 text-light">Functions == Comments</a>
            <a href="#Summary" class="nav-link p-3 text-light">Summary</a>
        </nav>
    </div>


    <main id="main-doc">
        <section class="main-section" id="Functions">
            <header>Functions</header>
            <p>Quite often we need to perform a similar action in many places of the script.<br>

                For example, we need to show a nice-looking message when a visitor logs in, logs out and maybe somewhere
                else.<br>

                Functions are the main “building blocks” of the program. They allow the code to be called many times
                without repetition.<br>

                We’ve already seen examples of built-in functions, like alert(message), prompt(message, default) and
                confirm(question). But we can create functions of our own as well.
            </p>

        </section>

        <section class="main-section" id="Function_declaration">
            <header>Function declaration</header>
            <p>To create a function we can use a function declaration.<br>

                It looks like this:
            </p>
            <code>
<pre>
function showMessage() {
  alert( 'Hello everyone!' );
}
</pre>
            </code>
            <p>The function keyword goes first, then goes the name of the function, then a list of parameters between
                the parentheses (comma-separated, empty in the example above, we’ll see examples later) and finally the
                code of the function, also named “the function body”, between curly braces.
            </p>
            <code>
<pre>
function name(parameter1, parameter2, ... parameterN) {
  ...body...
}
</pre>
            </code>
            <p>Our new function can be called by its name: showMessage().<br>

                For instance:</p>
            <code>
<pre>
function showMessage() {
  alert( 'Hello everyone!' );
}

showMessage();
showMessage();
</pre>
            </code>
            <p>The call showMessage() executes the code of the function. Here we will see the message two times. <br>

                This example clearly demonstrates one of the main purposes of functions: to avoid code duplication. <br>

                If we ever need to change the message or the way it is shown, it’s enough to modify the code in one
                place: the function which outputs it.</p>
        </section>


        <section class="main-section" id="Local_variables">
            <header>Local variables</header>
            <p>A variable declared inside a function is only visible inside that function.<br>

                For example:
            </p>
            <code>
<pre>
function showMessage() {
  let message = "Hello, I'm JavaScript!"; // local variable

  alert( message );
}

showMessage(); // Hello, I'm JavaScript!

alert( message ); // <-- Error! The variable is local to the function 
</pre>
             </code>
        </section>


        <section class="main-section" id="Outer_variables">
            <header>Outer variables</header>
            <p>A function can access an outer variable as well, for example:</p>
            <code>
<pre>
let userName = 'John';

function showMessage() {
  let message = 'Hello, ' + userName;
  alert(message);
}

showMessage(); // Hello, John
</pre>
            </code>
            <p>The function has full access to the outer variable. It can modify it as well.<br>

                For instance:</p>
            <code>
<pre>
let userName = 'John';

function showMessage() {
  userName = "Bob"; // (1) changed the outer variable

  let message = 'Hello, ' + userName;
  alert(message);
}

alert( userName ); // John before the function call

showMessage();

alert( userName ); // Bob, the value was modified by the function
</pre>
            </code>
            <p>The outer variable is only used if there’s no local one.<br>

                If a same-named variable is declared inside the function then it shadows the outer one. For instance, in
                the code below the function uses the local userName. The outer one is ignored:</p>
            <code>
<pre>
let userName = 'John';

function showMessage() {
  let userName = "Bob"; // declare a local variable

  let message = 'Hello, ' + userName; // Bob
  alert(message);
}

// the function will create and use its own userName
showMessage();

alert( userName ); // John, unchanged, the function did not access the outer variable

Global variables
</pre>
            </code>
            <span class="callout d-block">
                Global variables<br>

                Variables declared outside of any function, such as the outer userName in the code above, are called
                global.<br>

                Global variables are visible from any function (unless shadowed by locals).<br>

                It’s a good practice to minimize the use of global variables. Modern code has few or no globals. Most
                variables reside in their functions. Sometimes though, they can be useful to store project-level
                data.<br>
            </span>

        </section>

        <section class="main-section" id="Parameters">
            <header>Parameters</header>
            <p>We can pass arbitrary data to functions using parameters.<br>

                In the example below, the function has two parameters: from and text.</p>
            <code>
<pre>
function showMessage(from, text) { // parameters: from, text
  alert(from + ': ' + text);
}

showMessage('Ann', 'Hello!'); // Ann: Hello! (*)
showMessage('Ann', "What's up?"); // Ann: What's up? (**)
</pre>
            </code>
            <p>When the function is called in lines (*) and (**), the given values are copied to local variables from
                and text. Then the function uses them. <br>

                Here’s one more example: we have a variable from and pass it to the function. Please note: the function
                changes from, but the change is not seen outside, because a function always gets a copy of the value:
            </p>
            <code>
<pre>
function showMessage(from, text) {

  from = '*' + from + '*'; // make "from" look nicer

  alert( from + ': ' + text );
}

let from = "Ann";

showMessage(from, "Hello"); // *Ann*: Hello

// the value of "from" is the same, the function modified a local copy
alert( from ); // Ann
</pre>
            </code>
            <p>When a value is passed as a function parameter, it’s also called an argument.<br>

                In other words, to put these terms straight:<br>

            <ul>
                <li>A parameter is the variable listed inside the parentheses in the function declaration (it’s a
                    declaration time term)
                </li>
                <li>An argument is the value that is passed to the function when it is called (it’s a call time term).
                </li>
            </ul>
            We declare functions listing their parameters, then call them passing arguments.<br>

            In the example above, one might say: "the function showMessage is declared with two parameters, then
            called with two arguments: from and "Hello"".</p>

        </section>

        <section class="main-section" id="Default_values">
            <header>Default values</header>
            <p>If a function is called, but an argument is not provided, then the corresponding value becomes
                undefined.<br>

                For instance, the aforementioned function showMessage(from, text) can be called with a single argument:
            </p>
            <code>
<pre>
showMessage("Ann");
</pre>
            </code>
            <p>That’s not an error. Such a call would output "*Ann*: undefined". As the value for text isn’t passed, it
                becomes undefined.<br>

                We can specify the so-called “default” (to use if omitted) value for a parameter in the function
                declaration, using =:</p>
            <code>
<pre>
function showMessage(from, text = "no text given") {
  alert( from + ": " + text );
}

showMessage("Ann"); // Ann: no text given
</pre>
            </code>
            <p>Now if the text parameter is not passed, it will get the value "no text given"<br>

                Here "no text given" is a string, but it can be a more complex expression, which is only evaluated and
                assigned if the parameter is missing. So, this is also possible:</p>
            <code>
<pre>
function showMessage(from, text = anotherFunction()) {
  // anotherFunction() only executed if no text given
  // its result becomes the value of text
}
</pre>
            </code>
            <span class="callout d-block">

                Evaluation of default parameters<br>

                In JavaScript, a default parameter is evaluated every time the function is called without the respective
                parameter.<br>

                In the example above, anotherFunction() isn’t called at all, if the text parameter is provided.<br>

                On the other hand, it’s independently called every time when text is missing.<br>

            </span>
            <h2 class="subtitle">
                Alternative default parameters
            </h2>
            <p>Sometimes it makes sense to assign default values for parameters not in the function declaration, but at
                a later stage. <br>

                We can check if the parameter is passed during the function execution, by comparing it with undefined:
            </p>
            <code>
<pre>
function showMessage(text) {
  // ...

  if (text === undefined) { // if the parameter is missing
    text = 'empty message';
  }

  alert(text);
}

showMessage(); // empty message
</pre>
            </code>
            <p>…Or we could use the || operator:</p>
            <code>
<pre>
function showMessage(text) {
  // if text is undefined or otherwise falsy, set it to 'empty'
  text = text || 'empty';
  ...
}
</pre>
            </code>
            <p>Modern JavaScript engines support the nullish coalescing operator ??, it’s better when most falsy values,
                such as 0, should be considered “normal”:</p>
            <code>
<pre>
function showCount(count) {
  // if count is undefined or null, show "unknown"
  alert(count ?? "unknown");
}

showCount(0); // 0
showCount(null); // unknown
showCount(); // unknown
</pre>
            </code>

        </section>

        <section class="main-section" id="Returning_a_value">
            <header>Returning a value</header>
            <p>A function can return a value back into the calling code as the result.<br>

                The simplest example would be a function that sums two values:</p>
            <code>
<pre>
function sum(a, b) {
  return a + b;
}

let result = sum(1, 2);
alert( result ); // 3
</pre>
            </code>
            <p>
                The directive return can be in any place of the function. When the execution reaches it, the function
                stops, and the value is returned to the calling code (assigned to result above).<br>

                There may be many occurrences of return in a single function. For instance:
            </p>
            <code>
<pre>
function checkAge(age) {
  if (age >= 18) {
    return true;
  } else {
    return confirm('Do you have permission from your parents?');
  }
}

let age = prompt('How old are you?', 18);

if ( checkAge(age) ) {
  alert( 'Access granted' );
} else {
  alert( 'Access denied' );
}
</pre>
            </code>
            <p>It is possible to use return without a value. That causes the function to exit immediately.<br>

                For example:</p>
            <code>
<pre>
function showMovie(age) {
  if ( !checkAge(age) ) {
    return;
  }

  alert( "Showing you the movie" ); // (*)
  // ...
}
</pre>
            </code>
            <p>In the code above, if checkAge(age) returns false, then showMovie won’t proceed to the alert.</p>
            <span class="callout d-block">
                A function with an empty return or without it returns undefined

                If a function does not return a value, it is the same as if it returns undefined:
                <code>
<pre>
function doNothing() { /* empty */ }

alert( doNothing() === undefined ); // true
</pre>
                </code>

                An empty return is also the same as return undefined:
                <code>
<pre>
function doNothing() {
  return;
}

alert( doNothing() === undefined ); // true
</pre>
                </code>
            </span>

            <span class="callout d-block">
                Never add a newline between return and the value

                For a long expression in return, it might be tempting to put it on a separate line, like this:
                <code>
<pre>
return
 (some + long + expression + or + whatever * f(a) + f(b))
</pre>
                </code>

                So, it effectively becomes an empty return.<br>

                If we want the returned expression to wrap across multiple lines, we should start it at the same line as
                return. Or at least put the opening parentheses there as follows:
                <code>
<pre>
return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )
</pre>
                </code>
                And it will work just as we expect it to.
            </span>
        </section>

        <section class="main-section" id="Naming_a_function">
            <header>Naming a function</header>
            <p>
                Functions are actions. So their name is usually a verb. It should be brief, as accurate as possible and
                describe what the function does, so that someone reading the code gets an indication of what the
                function does.<br>

                It is a widespread practice to start a function with a verbal prefix which vaguely describes the action.
                There must be an agreement within the team on the meaning of the prefixes.<br>

                For instance, functions that start with "show" usually show something.<br>
                <br>
                Function starting with…<br>

            <ul>
                <li>"get…" – return a value,</li>
                <li>"calc…" – calculate something,</li>
                <li>"create…" – create something,</li>
                <li>"check…" – check something and return a boolean, etc.</li>
            </ul>
            Examples of such names:
            </p>
            <code>
<pre>
showMessage(..)     // shows a message
getAge(..)          // returns the age (gets it somehow)
calcSum(..)         // calculates a sum and returns the result
createForm(..)      // creates a form (and usually returns it)
checkPermission(..) // checks a permission, returns true/false
</pre>
            </code>
            <p>With prefixes in place, a glance at a function name gives an understanding what kind of work it does and
                what kind of value it returns.</p>

            <span class="callout d-block">

                One function – one action<br>

                A function should do exactly what is suggested by its name, no more.<br>

                Two independent actions usually deserve two functions, even if they are usually called together (in that
                case we can make a 3rd function that calls those two).<br>

                A few examples of breaking this rule:<br>

                getAge – would be bad if it shows an alert with the age (should only get).<br>
                createForm – would be bad if it modifies the document, adding a form to it (should only create it and
                return).<br>
                checkPermission – would be bad if it displays the access granted/denied message (should only perform the
                check and return the result).<br>

                These examples assume common meanings of prefixes. You and your team are free to agree on other
                meanings, but usually they’re not much different. In any case, you should have a firm understanding of
                what a prefix means, what a prefixed function can and cannot do. All same-prefixed functions should obey
                the rules. And the team should share the knowledge.
            </span>
            <span class="callout d-block">

                Ultrashort function names<br>

                Functions that are used very often sometimes have ultrashort names.<br>

                For example, the jQuery framework defines a function with $. The Lodash library has its core function
                named _.<br>

                These are exceptions. Generally function names should be concise and descriptive.<br>

            </span>

        </section>

        <section class="main-section" id="Functions_==_Comments">
            <header>Functions == Comments</header>
            <p>
                Functions should be short and do exactly one thing. If that thing is big, maybe it’s worth it to split
                the function into a few smaller functions. Sometimes following this rule may not be that easy, but it’s
                definitely a good thing.<br>

                A separate function is not only easier to test and debug – its very existence is a great comment!<br>

                For instance, compare the two functions showPrimes(n) below. Each one outputs prime numbers up to n.<br>

                The first variant uses a label:<br>
            </p>
            <code>
<pre>
function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {

    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // a prime
  }
}
</pre>
            </code>
            <p>
                The second variant uses an additional function isPrime(n) to test for primality:
            </p>

            <code>
<pre>
function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);  // a prime
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}
</pre>
            </code>
            <p>The second variant is easier to understand, isn’t it? Instead of the code piece we see a name of the
                action (isPrime). Sometimes people refer to such code as self-describing.<br>

                So, functions can be created even if we don’t intend to reuse them. They structure the code and make it
                readable.</p>

        </section>

        <section class="main-section" id="Summary">
            <header>Summary</header>
            <p>A function declaration looks like this:</p>
            <code>
<pre>
function name(parameters, delimited, by, comma) {
  /* code */
}
</pre>
            </code>
            <p>
            <ul>
                <li> Values passed to a function as parameters are copied to its local variables.</li>
                <li> A function may access outer variables. But it works only from inside out. The code outside of the
                    function doesn’t see its local variables.</li>
                <li> A function can return a value. If it doesn’t, then its result is undefined.</li>
            </ul>

            To make the code clean and easy to understand, it’s recommended to use mainly local variables and
            parameters in the function, not outer variables.<br>

            It is always easier to understand a function which gets parameters, works with them and returns a result
            than a function which gets no parameters, but modifies outer variables as a side-effect.<br>

            Function naming:<br>
            <ul>
                <li>A name should clearly describe what the function does. When we see a function call in the code, a
                    good
                <li> name instantly gives us an understanding what it does and returns.</li>
                <li> A function is an action, so function names are usually verbal.</li>
                <li> There exist many well-known function prefixes like create…, show…, get…, check… and so on. Use them
                    to
                <li> hint what a function does.</li>
            </ul>

            Functions are the main building blocks of scripts. Now we’ve covered the basics, so we actually can
            start creating and using them. But that’s only the beginning of the path. We are going to return to them
            many times, going more deeply into their advanced features.
            </p>
        </section>


    </main>

    <!-- Bootstrap javascript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-/bQdsTh/da6pkI1MST/rWKFNjaCP5gBSY4sEBT38Q/9RBh9AH40zEOg7Hlq2THRZ"
        crossorigin="anonymous"></script>
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
</body>

</html>